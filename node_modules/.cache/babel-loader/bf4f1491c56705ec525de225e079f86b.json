{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar bcUrRegistry = require('@keystonehq/bc-ur-registry');\n\nvar uuid = require('uuid');\n\nvar HDKey = _interopDefault(require('hdkey'));\n\nvar ethereumjsUtil = require('ethereumjs-util');\n\nconst {\n  RegistryType\n} = bcUrRegistry.extend;\nconst ExtendedRegistryTypes = {\n  ETH_SIGN_REQUEST: /*#__PURE__*/new RegistryType('eth-sign-request', 401),\n  ETH_SIGNATAURE: /*#__PURE__*/new RegistryType('eth-signature', 402)\n};\nconst {\n  decodeToDataItem,\n  RegistryTypes\n} = bcUrRegistry.extend;\nvar Keys;\n\n(function (Keys) {\n  Keys[Keys[\"requestId\"] = 1] = \"requestId\";\n  Keys[Keys[\"signData\"] = 2] = \"signData\";\n  Keys[Keys[\"dataType\"] = 3] = \"dataType\";\n  Keys[Keys[\"chainId\"] = 4] = \"chainId\";\n  Keys[Keys[\"derivationPath\"] = 5] = \"derivationPath\";\n  Keys[Keys[\"address\"] = 6] = \"address\";\n  Keys[Keys[\"origin\"] = 7] = \"origin\";\n})(Keys || (Keys = {}));\n\n(function (DataType) {\n  DataType[DataType[\"transaction\"] = 1] = \"transaction\";\n  DataType[DataType[\"typedData\"] = 2] = \"typedData\";\n  DataType[DataType[\"personalMessage\"] = 3] = \"personalMessage\";\n  DataType[DataType[\"typedTransaction\"] = 4] = \"typedTransaction\";\n})(exports.DataType || (exports.DataType = {}));\n\nclass EthSignRequest extends bcUrRegistry.RegistryItem {\n  constructor(args) {\n    super();\n\n    this.getRegistryType = () => ExtendedRegistryTypes.ETH_SIGN_REQUEST;\n\n    this.setupData = args => {\n      this.requestId = args.requestId;\n      this.signData = args.signData;\n      this.dataType = args.dataType;\n      this.chainId = args.chainId;\n      this.derivationPath = args.derivationPath;\n      this.address = args.address;\n      this.origin = args.origin;\n    };\n\n    this.getRequestId = () => this.requestId;\n\n    this.getSignData = () => this.signData;\n\n    this.getDataType = () => this.dataType;\n\n    this.getChainId = () => this.chainId;\n\n    this.getDerivationPath = () => this.derivationPath.getPath();\n\n    this.getSignRequestAddress = () => this.address;\n\n    this.getOrigin = () => this.origin;\n\n    this.toDataItem = () => {\n      const map = {};\n\n      if (this.requestId) {\n        map[Keys.requestId] = new bcUrRegistry.DataItem(this.requestId, RegistryTypes.UUID.getTag());\n      }\n\n      if (this.address) {\n        map[Keys.address] = this.address;\n      }\n\n      if (this.chainId) {\n        map[Keys.chainId] = this.chainId;\n      }\n\n      if (this.origin) {\n        map[Keys.origin] = this.origin;\n      }\n\n      map[Keys.signData] = this.signData;\n      map[Keys.dataType] = this.dataType;\n      const keyPath = this.derivationPath.toDataItem();\n      keyPath.setTag(this.derivationPath.getRegistryType().getTag());\n      map[Keys.derivationPath] = keyPath;\n      return new bcUrRegistry.DataItem(map);\n    };\n\n    this.setupData(args);\n  }\n\n  static constructETHRequest(signData, signDataType, hdPath, xfp, uuidString, chainId, address, origin) {\n    const paths = hdPath.replace(/[m|M]\\//, '').split('/');\n    const hdpathObject = new bcUrRegistry.CryptoKeypath(paths.map(path => {\n      const index = parseInt(path.replace(\"'\", ''));\n      let isHardened = false;\n\n      if (path.endsWith(\"'\")) {\n        isHardened = true;\n      }\n\n      return new bcUrRegistry.PathComponent({\n        index,\n        hardened: isHardened\n      });\n    }), Buffer.from(xfp, 'hex'));\n    return new EthSignRequest({\n      requestId: uuidString ? Buffer.from(uuid.parse(uuidString)) : undefined,\n      signData,\n      dataType: signDataType,\n      derivationPath: hdpathObject,\n      chainId,\n      address: address ? Buffer.from(address.replace('0x', ''), 'hex') : undefined,\n      origin: origin || undefined\n    });\n  }\n\n}\n\nEthSignRequest.fromDataItem = dataItem => {\n  const map = dataItem.getData();\n  const signData = map[Keys.signData];\n  const dataType = map[Keys.dataType];\n  const derivationPath = bcUrRegistry.CryptoKeypath.fromDataItem(map[Keys.derivationPath]);\n  const chainId = map[Keys.chainId] ? map[Keys.chainId] : undefined;\n  const address = map[Keys.address] ? map[Keys.address] : undefined;\n  const requestId = map[Keys.requestId] ? map[Keys.requestId].getData() : undefined;\n  const origin = map[Keys.origin] ? map[Keys.origin] : undefined;\n  return new EthSignRequest({\n    requestId,\n    signData,\n    dataType,\n    chainId,\n    derivationPath,\n    address,\n    origin\n  });\n};\n\nEthSignRequest.fromCBOR = _cborPayload => {\n  const dataItem = decodeToDataItem(_cborPayload);\n  return EthSignRequest.fromDataItem(dataItem);\n};\n\nconst {\n  RegistryTypes: RegistryTypes$1,\n  decodeToDataItem: decodeToDataItem$1\n} = bcUrRegistry.extend;\nvar Keys$1;\n\n(function (Keys) {\n  Keys[Keys[\"requestId\"] = 1] = \"requestId\";\n  Keys[Keys[\"signature\"] = 2] = \"signature\";\n})(Keys$1 || (Keys$1 = {}));\n\nclass ETHSignature extends bcUrRegistry.RegistryItem {\n  constructor(signature, requestId) {\n    super();\n\n    this.getRegistryType = () => ExtendedRegistryTypes.ETH_SIGNATAURE;\n\n    this.getRequestId = () => this.requestId;\n\n    this.getSignature = () => this.signature;\n\n    this.toDataItem = () => {\n      const map = {};\n\n      if (this.requestId) {\n        map[Keys$1.requestId] = new bcUrRegistry.DataItem(this.requestId, RegistryTypes$1.UUID.getTag());\n      }\n\n      map[Keys$1.signature] = this.signature;\n      return new bcUrRegistry.DataItem(map);\n    };\n\n    this.signature = signature;\n    this.requestId = requestId;\n  }\n\n}\n\nETHSignature.fromDataItem = dataItem => {\n  const map = dataItem.getData();\n  const signature = map[Keys$1.signature];\n  const requestId = map[Keys$1.requestId] ? map[Keys$1.requestId].getData() : undefined;\n  return new ETHSignature(signature, requestId);\n};\n\nETHSignature.fromCBOR = _cborPayload => {\n  const dataItem = decodeToDataItem$1(_cborPayload);\n  return ETHSignature.fromDataItem(dataItem);\n}; // @ts-ignore\n\n\nconst generateAddressfromXpub = (xpub, derivePath) => {\n  // @ts-ignore\n  const node = HDKey.fromExtendedKey(xpub);\n  const publicKey = node.derive(derivePath);\n  const address = '0x' + ethereumjsUtil.publicToAddress(publicKey.publicKey, true).toString('hex');\n  return ethereumjsUtil.toChecksumAddress(address);\n};\n\nconst findHDpatfromAddress = (address, xpub, numberLimit, rootPath) => {\n  for (let i = 0; i < numberLimit; i++) {\n    const path = `M/0/${i}`;\n    const caculateAddress = generateAddressfromXpub(xpub, path);\n\n    if (address.toLowerCase() == caculateAddress.toLowerCase()) {\n      return `${rootPath}/0/${i}`;\n    }\n  }\n\n  return null;\n};\n\nconst {\n  cbor\n} = bcUrRegistry.extend;\ncbor.patchTags(Object.values(ExtendedRegistryTypes).filter(rt => !!rt.getTag()).map(rt => rt.getTag()));\nObject.keys(bcUrRegistry).forEach(function (k) {\n  if (k !== 'default') Object.defineProperty(exports, k, {\n    enumerable: true,\n    get: function () {\n      return bcUrRegistry[k];\n    }\n  });\n});\nexports.ETHSignature = ETHSignature;\nexports.EthSignRequest = EthSignRequest;\nexports.findHDpatfromAddress = findHDpatfromAddress;\nexports.generateAddressfromXpub = generateAddressfromXpub;","map":{"version":3,"sources":["../src/RegistryType.ts","../src/EthSignRequest.ts","../src/EthSignature.ts","../src/utlis.ts","../src/index.ts"],"names":["RegistryType","extend","ExtendedRegistryTypes","ETH_SIGN_REQUEST","ETH_SIGNATAURE","RegistryTypes","Keys","DataType","EthSignRequest","RegistryItem","constructor","args","map","DataItem","keyPath","dataItem","signData","dataType","derivationPath","CryptoKeypath","chainId","address","requestId","origin","_cborPayload","decodeToDataItem","constructETHRequest","paths","hdPath","hdpathObject","path","index","parseInt","isHardened","PathComponent","hardened","Buffer","uuidString","uuid","undefined","ETHSignature","signature","generateAddressfromXpub","node","HDKey","publicKey","publicToAddress","toChecksumAddress","findHDpatfromAddress","i","caculateAddress","rootPath","cbor","Object","rt"],"mappings":"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","sourcesContent":["import { extend } from '@keystonehq/bc-ur-registry';\nconst { RegistryType } = extend;\n\nexport const ExtendedRegistryTypes = {\n    ETH_SIGN_REQUEST: new RegistryType('eth-sign-request', 401),\n    ETH_SIGNATAURE: new RegistryType('eth-signature', 402),\n};\n","import { CryptoKeypath, extend, DataItem, PathComponent, RegistryItem } from '@keystonehq/bc-ur-registry';\nimport { ExtendedRegistryTypes } from './RegistryType';\nimport * as uuid from 'uuid';\n\nconst { decodeToDataItem, RegistryTypes } = extend;\n\nenum Keys {\n    requestId = 1,\n    signData,\n    dataType,\n    chainId,\n    derivationPath,\n    address,\n    origin\n}\n\nexport enum DataType {\n    transaction = 1,\n    typedData = 2,\n    personalMessage = 3,\n    typedTransaction = 4,\n}\n\ntype signRequestProps = {\n    requestId?: Buffer;\n    signData: Buffer;\n    dataType: DataType;\n    chainId?: number;\n    derivationPath: CryptoKeypath;\n    address?: Buffer;\n    origin?: String;\n};\n\nexport class EthSignRequest extends RegistryItem {\n    private requestId: Buffer;\n    private signData: Buffer;\n    private dataType: DataType;\n    private chainId: number;\n    private derivationPath: CryptoKeypath;\n    private address: Buffer;\n    private origin: String;\n\n    getRegistryType = () => ExtendedRegistryTypes.ETH_SIGN_REQUEST;\n\n    constructor(args: signRequestProps) {\n        super();\n        this.setupData(args);\n    }\n\n    private setupData = (args: signRequestProps) => {\n        this.requestId = args.requestId;\n        this.signData = args.signData;\n        this.dataType = args.dataType;\n        this.chainId = args.chainId;\n        this.derivationPath = args.derivationPath;\n        this.address = args.address;\n        this.origin = args.origin;\n    };\n\n    public getRequestId = () => this.requestId;\n    public getSignData = () => this.signData;\n    public getDataType = () => this.dataType;\n    public getChainId = () => this.chainId;\n    public getDerivationPath = () => this.derivationPath.getPath();\n    public getSignRequestAddress = () => this.address;\n    public getOrigin = () => this.origin;\n\n    public toDataItem = () => {\n        const map = {};\n        if (this.requestId) {\n            map[Keys.requestId] = new DataItem(this.requestId, RegistryTypes.UUID.getTag());\n        }\n        if (this.address) {\n            map[Keys.address] = this.address;\n        }\n        if (this.chainId) {\n            map[Keys.chainId] = this.chainId;\n        }\n\n        if(this.origin) {\n            map[Keys.origin] = this.origin;\n        }\n\n        map[Keys.signData] = this.signData;\n        map[Keys.dataType] = this.dataType;\n\n        const keyPath = this.derivationPath.toDataItem();\n        keyPath.setTag(this.derivationPath.getRegistryType().getTag());\n        map[Keys.derivationPath] = keyPath;\n\n        return new DataItem(map);\n    };\n\n    public static fromDataItem = (dataItem) => {\n        const map = dataItem.getData();\n        const signData = map[Keys.signData];\n        const dataType = map[Keys.dataType];\n        const derivationPath = CryptoKeypath.fromDataItem(map[Keys.derivationPath]);\n        const chainId = map[Keys.chainId] ? map[Keys.chainId] : undefined;\n        const address = map[Keys.address] ? map[Keys.address] : undefined;\n        const requestId = map[Keys.requestId] ? map[Keys.requestId].getData() : undefined;\n        const origin = map[Keys.origin] ? map[Keys.origin] : undefined;\n\n        return new EthSignRequest({\n            requestId,\n            signData,\n            dataType,\n            chainId,\n            derivationPath,\n            address,\n            origin\n        });\n    };\n\n    public static fromCBOR = (_cborPayload: Buffer) => {\n        const dataItem = decodeToDataItem(_cborPayload);\n        return EthSignRequest.fromDataItem(dataItem);\n    };\n\n    public static constructETHRequest(\n        signData: Buffer,\n        signDataType: DataType,\n        hdPath: string,\n        xfp: string,\n        uuidString?: string,\n        chainId?: number,\n        address?: string,\n        origin?: string,\n    ) {\n        const paths = hdPath.replace(/[m|M]\\//, '').split('/');\n        const hdpathObject = new CryptoKeypath(\n            paths.map((path) => {\n                const index = parseInt(path.replace(\"'\", ''));\n                let isHardened = false;\n                if (path.endsWith(\"'\")) {\n                    isHardened = true;\n                }\n                return new PathComponent({ index, hardened: isHardened });\n            }),\n            Buffer.from(xfp, 'hex'),\n        );\n\n        return new EthSignRequest({\n            requestId: uuidString ? Buffer.from(uuid.parse(uuidString) as Uint8Array) : undefined,\n            signData,\n            dataType: signDataType,\n            derivationPath: hdpathObject,\n            chainId,\n            address: address ? Buffer.from(address.replace('0x', ''), 'hex') : undefined,\n            origin: origin || undefined,\n        });\n    }\n}\n","import { extend, DataItem, RegistryItem } from '@keystonehq/bc-ur-registry';\nimport { ExtendedRegistryTypes } from './RegistryType';\n\nconst { RegistryTypes, decodeToDataItem } = extend;\n\nenum Keys {\n    requestId = 1,\n    signature,\n}\n\nexport class ETHSignature extends RegistryItem {\n    private requestId: Buffer;\n    private signature: Buffer;\n\n    getRegistryType = () => ExtendedRegistryTypes.ETH_SIGNATAURE;\n\n    constructor(signature: Buffer, requestId?: Buffer) {\n        super();\n        this.signature = signature;\n        this.requestId = requestId;\n    }\n\n    public getRequestId = () => this.requestId;\n    public getSignature = () => this.signature;\n\n    public toDataItem = () => {\n        const map = {};\n        if (this.requestId) {\n            map[Keys.requestId] = new DataItem(this.requestId, RegistryTypes.UUID.getTag());\n        }\n        map[Keys.signature] = this.signature;\n        return new DataItem(map);\n    };\n\n    public static fromDataItem = (dataItem) => {\n        const map = dataItem.getData();\n        const signature = map[Keys.signature];\n        const requestId = map[Keys.requestId] ? map[Keys.requestId].getData() : undefined;\n\n        return new ETHSignature(signature, requestId);\n    };\n\n    public static fromCBOR = (_cborPayload: Buffer) => {\n        const dataItem = decodeToDataItem(_cborPayload);\n        return ETHSignature.fromDataItem(dataItem);\n    };\n}\n","// @ts-ignore\nimport HDKey from 'hdkey';\nimport { toChecksumAddress, publicToAddress } from 'ethereumjs-util';\n\nexport const generateAddressfromXpub = (xpub: string, derivePath: string) => {\n    // @ts-ignore\n    const node = HDKey.fromExtendedKey(xpub);\n    const publicKey = node.derive(derivePath);\n    const address = '0x' + publicToAddress(publicKey.publicKey, true).toString('hex');\n    return toChecksumAddress(address);\n};\n\nexport const findHDpatfromAddress = (address: string, xpub: string, numberLimit: number, rootPath: string) => {\n    for (let i = 0; i < numberLimit; i++) {\n        const path = `M/0/${i}`;\n        const caculateAddress = generateAddressfromXpub(xpub, path);\n        if (address.toLowerCase() == caculateAddress.toLowerCase()) {\n            return `${rootPath}/0/${i}`;\n        }\n    }\n    return null;\n};\n","export * from '@keystonehq/bc-ur-registry';\nimport { extend } from '@keystonehq/bc-ur-registry';\nimport { ExtendedRegistryTypes } from './RegistryType';\nconst { cbor } = extend;\ncbor.patchTags(\n    Object.values(ExtendedRegistryTypes)\n        .filter((rt) => !!rt.getTag())\n        .map((rt) => rt.getTag()),\n);\n\nexport { EthSignRequest, DataType } from './EthSignRequest';\nexport { ETHSignature } from './EthSignature';\n\nexport { generateAddressfromXpub, findHDpatfromAddress } from './utlis';\n"]},"metadata":{},"sourceType":"script"}