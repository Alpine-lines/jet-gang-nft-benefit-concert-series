{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar HDKey = _interopDefault(require('hdkey'));\n\nvar ethereumjsUtil = require('ethereumjs-util');\n\nvar tx = require('@ethereumjs/tx');\n\nvar bcUrRegistryEth = require('@keystonehq/bc-ur-registry-eth');\n\nvar uuid = require('uuid');\n\nconst keyringType = 'QR Hardware Wallet Device';\nconst pathBase = 'm';\nconst MAX_INDEX = 1000;\n\nclass BaseKeyring {\n  constructor(opts) {\n    this.getInteraction = () => {\n      throw new Error('#ktek_error, method getInteraction not implemented, please extend BaseKeyring by overwriting this method.');\n    };\n\n    this.type = keyringType;\n\n    this.readKeyringCryptoHDKey = async () => {\n      var _cryptoHDKey$getOrigi;\n\n      const cryptoHDKey = await this.getInteraction().readCryptoHDKey();\n      const hdPath = `m/${cryptoHDKey.getOrigin().getPath()}`;\n      const xfp = (_cryptoHDKey$getOrigi = cryptoHDKey.getOrigin().getSourceFingerprint()) == null ? void 0 : _cryptoHDKey$getOrigi.toString('hex');\n\n      if (!xfp) {\n        throw new Error('invalid crypto-hd-key, cannot get source fingerprint');\n      }\n\n      const xpub = cryptoHDKey.getBip32Key();\n      return {\n        xfp,\n        xpub,\n        hdPath\n      };\n    };\n\n    this.requestSignature = async (_requestId, signRequest, requestTitle, requestDescription) => {\n      const ethSignature = await this.getInteraction().requestSignature(signRequest, requestTitle, requestDescription);\n      const requestIdBuffer = ethSignature.getRequestId();\n      const signature = ethSignature.getSignature();\n\n      if (requestIdBuffer) {\n        const requestId = uuid.stringify(requestIdBuffer);\n\n        if (requestId !== _requestId) {\n          throw new Error('read signature error: mismatched requestId');\n        }\n      }\n\n      const r = signature.slice(0, 32);\n      const s = signature.slice(32, 64);\n      const v = signature.slice(64);\n      return {\n        r,\n        s,\n        v\n      };\n    };\n\n    this.xfp = '';\n    this.xpub = '';\n    this.hdPath = '';\n    this.page = 0;\n    this.perPage = 5;\n    this.accounts = [];\n    this.currentAccount = 0;\n    this.paths = {};\n    this.latestAccount = 0;\n    this.deserialize(opts);\n  }\n\n  async readKeyring() {\n    const {\n      xpub,\n      xfp,\n      hdPath\n    } = await this.readKeyringCryptoHDKey();\n    this.xfp = xfp;\n    this.xpub = xpub;\n    this.hdPath = hdPath;\n  }\n\n  checkKeyring() {\n    if (!this.xfp || !this.xpub || !this.hdPath) {\n      throw new Error('keyring not fulfilled, please call function `readKeyring` firstly');\n    }\n  }\n\n  serialize() {\n    return Promise.resolve({\n      xfp: this.xfp,\n      xpub: this.xpub,\n      hdPath: this.hdPath,\n      accounts: this.accounts,\n      currentAccount: this.currentAccount,\n      page: this.page,\n      perPage: this.perPage,\n      paths: this.paths\n    });\n  }\n\n  deserialize(opts) {\n    if (opts) {\n      this.xfp = opts.xfp;\n      this.xpub = opts.xpub;\n      this.hdPath = opts.hdPath;\n      this.accounts = opts.accounts;\n      this.currentAccount = opts.currentAccount;\n      this.page = opts.page;\n      this.perPage = opts.perPage;\n      this.paths = opts.paths;\n    }\n  }\n\n  setCurrentAccount(index) {\n    this.currentAccount = index;\n  }\n\n  getCurrentAccount() {\n    return this.currentAccount;\n  }\n\n  getCurrentAddress() {\n    return this.accounts[this.currentAccount];\n  }\n\n  addAccounts() {\n    let n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    return new Promise((resolve, reject) => {\n      try {\n        const from = this.latestAccount;\n        const to = from + n;\n        const newAccounts = [];\n\n        for (let i = from; i < to; i++) {\n          const address = this._addressFromIndex(pathBase, i);\n\n          newAccounts.push(address);\n          this.page = 0;\n          this.latestAccount++;\n        }\n\n        this.accounts = this.accounts.concat(newAccounts);\n        resolve(this.accounts);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  getFirstPage() {\n    this.page = 0;\n    return this.__getPage(1);\n  }\n\n  getNextPage() {\n    return this.__getPage(1);\n  }\n\n  getPreviousPage() {\n    return this.__getPage(-1);\n  }\n\n  async __getPage(increment) {\n    this.page += increment;\n\n    if (this.page <= 0) {\n      this.page = 1;\n    }\n\n    if (!!!this.xfp) {\n      await this.readKeyring();\n    }\n\n    return new Promise((resolve, reject) => {\n      try {\n        const from = (this.page - 1) * this.perPage;\n        const to = from + this.perPage;\n        const accounts = [];\n\n        for (let i = from; i < to; i++) {\n          const address = this._addressFromIndex(pathBase, i);\n\n          accounts.push({\n            address,\n            balance: null,\n            index: i\n          });\n          this.paths[ethereumjsUtil.toChecksumAddress(address)] = i;\n        }\n\n        resolve(accounts);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  getAccounts() {\n    return Promise.resolve(this.accounts);\n  }\n\n  removeAccount(address) {\n    if (!this.accounts.map(a => a.toLowerCase()).includes(address.toLowerCase())) {\n      throw new Error(`Address ${address} not found in this keyring`);\n    }\n\n    this.accounts = this.accounts.filter(a => a.toLowerCase() !== address.toLowerCase());\n  } // tx is an instance of the ethereumjs-transaction class.\n\n\n  static serializeTx(tx) {\n    // need use EIP-155\n    // @ts-ignore\n    tx.v = new ethereumjsUtil.BN(tx.common.chainId()); // @ts-ignore\n\n    tx.r = new ethereumjsUtil.BN(0); // @ts-ignore\n\n    tx.s = new ethereumjsUtil.BN(0);\n    return tx.serialize();\n  }\n\n  async signTransaction(address, tx$1) {\n    const hdPath = this._pathFromAddress(address);\n\n    const chainId = tx$1.common.chainId();\n    const requestId = uuid.v4();\n    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(BaseKeyring.serializeTx(tx$1), bcUrRegistryEth.DataType.transaction, hdPath, this.xfp, requestId, chainId);\n    const {\n      r,\n      s,\n      v\n    } = await this.requestSignature(requestId, ethSignRequest, 'Scan with your Keystone', 'After your Keystone has signed the transaction, click on \"Scan Keystone\" to receive the signature');\n    const txJson = tx$1.toJSON();\n    return tx.Transaction.fromTxData({\n      to: txJson['to'],\n      gasLimit: txJson['gasLimit'],\n      gasPrice: txJson['gasPrice'],\n      data: txJson['data'],\n      nonce: txJson['nonce'],\n      value: txJson['value'],\n      r,\n      s,\n      v\n    }, {\n      common: tx$1.common\n    });\n  }\n\n  signMessage(withAccount, data) {\n    return this.signPersonalMessage(withAccount, data);\n  }\n\n  async signPersonalMessage(withAccount, messageHex) {\n    const usignedHex = ethereumjsUtil.stripHexPrefix(messageHex);\n\n    const hdPath = this._pathFromAddress(withAccount);\n\n    const requestId = uuid.v4();\n    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(Buffer.from(usignedHex, 'hex'), bcUrRegistryEth.DataType.personalMessage, hdPath, this.xfp, requestId, undefined, withAccount);\n    const {\n      r,\n      s,\n      v\n    } = await this.requestSignature(requestId, ethSignRequest, 'Scan with your Keystone', 'After your Keystone has signed this message, click on \"Scan Keystone\" to receive the signature');\n    return '0x' + Buffer.concat([r, s, v]).toString('hex');\n  }\n\n  async signTypedData(withAccount, typedData) {\n    const hdPath = this._pathFromAddress(withAccount);\n\n    const requestId = uuid.v4();\n    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(Buffer.from(JSON.stringify(typedData), 'utf-8'), bcUrRegistryEth.DataType.typedData, hdPath, this.xfp, requestId, undefined, withAccount);\n    const {\n      r,\n      s,\n      v\n    } = await this.requestSignature(requestId, ethSignRequest, 'Scan with your Keystone', 'After your Keystone has signed this data, click on \"Scan Keystone\" to receive the signature');\n    return '0x' + Buffer.concat([r, s, v]).toString('hex');\n  }\n\n  _addressFromIndex(pb, i) {\n    this.checkKeyring();\n\n    if (!this.hdk) {\n      // @ts-ignore\n      this.hdk = HDKey.fromExtendedKey(this.xpub);\n    }\n\n    const dkey = this.hdk.derive(`${pb}/0/${i}`);\n    const address = '0x' + ethereumjsUtil.publicToAddress(dkey.publicKey, true).toString('hex');\n    return ethereumjsUtil.toChecksumAddress(address);\n  }\n\n  _pathFromAddress(address) {\n    const checksummedAddress = ethereumjsUtil.toChecksumAddress(address);\n    let index = this.paths[checksummedAddress];\n\n    if (typeof index === 'undefined') {\n      for (let i = 0; i < MAX_INDEX; i++) {\n        if (checksummedAddress === this._addressFromIndex(pathBase, i)) {\n          index = i;\n          break;\n        }\n      }\n    }\n\n    if (typeof index === 'undefined') {\n      throw new Error('Unknown address');\n    }\n\n    return `${this.hdPath}/0/${index}`;\n  }\n\n}\n\nBaseKeyring.type = keyringType;\nexports.BaseKeyring = BaseKeyring;","map":{"version":3,"sources":["../src/BaseKeyring.ts"],"names":["keyringType","pathBase","MAX_INDEX","BaseKeyring","constructor","opts","cryptoHDKey","hdPath","xfp","xpub","ethSignature","requestIdBuffer","signature","requestId","uuid","r","s","v","readKeyring","checkKeyring","serialize","accounts","currentAccount","page","perPage","paths","deserialize","setCurrentAccount","getCurrentAccount","getCurrentAddress","addAccounts","n","from","to","newAccounts","i","address","resolve","reject","getFirstPage","getNextPage","getPreviousPage","__getPage","balance","index","toChecksumAddress","getAccounts","Promise","removeAccount","a","serializeTx","tx","BN","signTransaction","chainId","ethSignRequest","EthSignRequest","DataType","txJson","gasLimit","gasPrice","data","nonce","value","common","signMessage","signPersonalMessage","usignedHex","stripHexPrefix","Buffer","signTypedData","JSON","_addressFromIndex","HDKey","dkey","pb","publicToAddress","_pathFromAddress","checksummedAddress"],"mappings":"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","sourcesContent":["import HDKey from 'hdkey';\nimport { toChecksumAddress, publicToAddress, BN, stripHexPrefix } from 'ethereumjs-util';\nimport { Transaction } from '@ethereumjs/tx';\nimport { DataType, EthSignRequest } from '@keystonehq/bc-ur-registry-eth';\nimport * as uuid from 'uuid';\nimport { InteractionProvider } from './InteractionProvider';\n\nconst keyringType = 'QR Hardware Wallet Device';\nconst pathBase = 'm';\nconst MAX_INDEX = 1000;\n\nexport type StoredKeyring = {\n    xfp: string;\n    xpub: string;\n    hdPath: string;\n    accounts: string[];\n    currentAccount: number;\n    page: number;\n    perPage: number;\n    paths: Record<string, number>;\n};\n\nexport type PagedAccount = { address: string; balance: any; index: number };\n\nexport class BaseKeyring {\n    getInteraction = (): InteractionProvider => {\n        throw new Error(\n            '#ktek_error, method getInteraction not implemented, please extend BaseKeyring by overwriting this method.',\n        );\n    };\n    static type = keyringType;\n    protected xfp: string;\n    protected type = keyringType;\n    protected xpub: string;\n    protected hdPath: string;\n    protected accounts: string[];\n    protected currentAccount: number;\n    protected page: number;\n    protected perPage: number;\n    protected paths: Record<string, number>;\n    protected hdk: HDKey;\n    protected latestAccount: number;\n\n    constructor(opts?: StoredKeyring) {\n        this.xfp = '';\n        this.xpub = '';\n        this.hdPath = '';\n        this.page = 0;\n        this.perPage = 5;\n        this.accounts = [];\n        this.currentAccount = 0;\n        this.paths = {};\n        this.latestAccount = 0;\n        this.deserialize(opts);\n    }\n\n    private readKeyringCryptoHDKey = async (): Promise<{ xfp: string; xpub: string; hdPath: string }> => {\n        const cryptoHDKey = await this.getInteraction().readCryptoHDKey();\n        const hdPath = `m/${cryptoHDKey.getOrigin().getPath()}`;\n        const xfp = cryptoHDKey.getOrigin().getSourceFingerprint()?.toString('hex');\n        if (!xfp) {\n            throw new Error('invalid crypto-hd-key, cannot get source fingerprint');\n        }\n        const xpub = cryptoHDKey.getBip32Key();\n        return {\n            xfp,\n            xpub,\n            hdPath,\n        };\n    };\n\n    protected requestSignature = async (\n        _requestId: string,\n        signRequest: EthSignRequest,\n        requestTitle?: string,\n        requestDescription?: string,\n    ): Promise<{ r: Buffer; s: Buffer; v: Buffer }> => {\n        const ethSignature = await this.getInteraction().requestSignature(\n            signRequest,\n            requestTitle,\n            requestDescription,\n        );\n        const requestIdBuffer = ethSignature.getRequestId();\n        const signature = ethSignature.getSignature();\n        if (requestIdBuffer) {\n            const requestId = uuid.stringify(requestIdBuffer);\n            if (requestId !== _requestId) {\n                throw new Error('read signature error: mismatched requestId');\n            }\n        }\n        const r = signature.slice(0, 32);\n        const s = signature.slice(32, 64);\n        const v = signature.slice(64);\n        return {\n            r,\n            s,\n            v,\n        };\n    };\n\n    async readKeyring(): Promise<void> {\n        const { xpub, xfp, hdPath } = await this.readKeyringCryptoHDKey();\n        this.xfp = xfp;\n        this.xpub = xpub;\n        this.hdPath = hdPath;\n    }\n\n    protected checkKeyring() {\n        if (!this.xfp || !this.xpub || !this.hdPath) {\n            throw new Error('keyring not fulfilled, please call function `readKeyring` firstly');\n        }\n    }\n\n    serialize(): Promise<StoredKeyring> {\n        return Promise.resolve({\n            xfp: this.xfp,\n            xpub: this.xpub,\n            hdPath: this.hdPath,\n            accounts: this.accounts,\n            currentAccount: this.currentAccount,\n            page: this.page,\n            perPage: this.perPage,\n            paths: this.paths,\n        });\n    }\n\n    deserialize(opts?: StoredKeyring): void {\n        if (opts) {\n            this.xfp = opts.xfp;\n            this.xpub = opts.xpub;\n            this.hdPath = opts.hdPath;\n            this.accounts = opts.accounts;\n            this.currentAccount = opts.currentAccount;\n            this.page = opts.page;\n            this.perPage = opts.perPage;\n            this.paths = opts.paths;\n        }\n    }\n\n    setCurrentAccount(index: number): void {\n        this.currentAccount = index;\n    }\n\n    getCurrentAccount(): number {\n        return this.currentAccount;\n    }\n\n    getCurrentAddress(): string {\n        return this.accounts[this.currentAccount];\n    }\n\n    addAccounts(n = 1): Promise<string[]> {\n        return new Promise((resolve, reject) => {\n            try {\n                const from = this.latestAccount;\n                const to = from + n;\n                const newAccounts = [];\n\n                for (let i = from; i < to; i++) {\n                    const address = this._addressFromIndex(pathBase, i);\n                    newAccounts.push(address);\n                    this.page = 0;\n                    this.latestAccount++;\n                }\n                this.accounts = this.accounts.concat(newAccounts);\n                resolve(this.accounts);\n            } catch (e) {\n                reject(e);\n            }\n        });\n    }\n\n    getFirstPage(): Promise<PagedAccount[]> {\n        this.page = 0;\n        return this.__getPage(1);\n    }\n\n    getNextPage(): Promise<PagedAccount[]> {\n        return this.__getPage(1);\n    }\n\n    getPreviousPage(): Promise<PagedAccount[]> {\n        return this.__getPage(-1);\n    }\n\n    async __getPage(increment: number): Promise<PagedAccount[]> {\n        this.page += increment;\n\n        if (this.page <= 0) {\n            this.page = 1;\n        }\n\n        if (!!!this.xfp) {\n            await this.readKeyring();\n        }\n\n        return new Promise((resolve, reject) => {\n            try {\n                const from = (this.page - 1) * this.perPage;\n                const to = from + this.perPage;\n\n                const accounts = [];\n\n                for (let i = from; i < to; i++) {\n                    const address = this._addressFromIndex(pathBase, i);\n                    accounts.push({\n                        address,\n                        balance: null,\n                        index: i,\n                    });\n                    this.paths[toChecksumAddress(address)] = i;\n                }\n                resolve(accounts);\n            } catch (e) {\n                reject(e);\n            }\n        });\n    }\n\n    getAccounts() {\n        return Promise.resolve(this.accounts);\n    }\n\n    removeAccount(address: string): void {\n        if (!this.accounts.map((a) => a.toLowerCase()).includes(address.toLowerCase())) {\n            throw new Error(`Address ${address} not found in this keyring`);\n        }\n        this.accounts = this.accounts.filter((a) => a.toLowerCase() !== address.toLowerCase());\n    }\n\n    // tx is an instance of the ethereumjs-transaction class.\n\n    private static serializeTx(tx: Transaction): Buffer {\n        // need use EIP-155\n        // @ts-ignore\n        tx.v = new BN(tx.common.chainId());\n        // @ts-ignore\n        tx.r = new BN(0);\n        // @ts-ignore\n        tx.s = new BN(0);\n        return tx.serialize();\n    }\n\n    async signTransaction(address: string, tx: Transaction): Promise<Transaction> {\n        const hdPath = this._pathFromAddress(address);\n        const chainId = tx.common.chainId();\n        const requestId = uuid.v4();\n        const ethSignRequest = EthSignRequest.constructETHRequest(\n            BaseKeyring.serializeTx(tx),\n            DataType.transaction,\n            hdPath,\n            this.xfp,\n            requestId,\n            chainId,\n        );\n\n        const { r, s, v } = await this.requestSignature(\n            requestId,\n            ethSignRequest,\n            'Scan with your Keystone',\n            'After your Keystone has signed the transaction, click on \"Scan Keystone\" to receive the signature',\n        );\n        const txJson = tx.toJSON();\n        return Transaction.fromTxData(\n            {\n                to: txJson['to'],\n                gasLimit: txJson['gasLimit'],\n                gasPrice: txJson['gasPrice'],\n                data: txJson['data'],\n                nonce: txJson['nonce'],\n                value: txJson['value'],\n                r,\n                s,\n                v,\n            },\n            { common: tx.common },\n        );\n    }\n\n    signMessage(withAccount: string, data: string): Promise<string> {\n        return this.signPersonalMessage(withAccount, data);\n    }\n\n    async signPersonalMessage(withAccount: string, messageHex: string): Promise<string> {\n        const usignedHex = stripHexPrefix(messageHex);\n        const hdPath = this._pathFromAddress(withAccount);\n        const requestId = uuid.v4();\n        const ethSignRequest = EthSignRequest.constructETHRequest(\n            Buffer.from(usignedHex, 'hex'),\n            DataType.personalMessage,\n            hdPath,\n            this.xfp,\n            requestId,\n            undefined,\n            withAccount,\n        );\n        const { r, s, v } = await this.requestSignature(\n            requestId,\n            ethSignRequest,\n            'Scan with your Keystone',\n            'After your Keystone has signed this message, click on \"Scan Keystone\" to receive the signature',\n        );\n        return '0x' + Buffer.concat([r, s, v]).toString('hex');\n    }\n\n    async signTypedData(withAccount: string, typedData: any): Promise<string> {\n        const hdPath = this._pathFromAddress(withAccount);\n        const requestId = uuid.v4();\n        const ethSignRequest = EthSignRequest.constructETHRequest(\n            Buffer.from(JSON.stringify(typedData), 'utf-8'),\n            DataType.typedData,\n            hdPath,\n            this.xfp,\n            requestId,\n            undefined,\n            withAccount,\n        );\n        const { r, s, v } = await this.requestSignature(\n            requestId,\n            ethSignRequest,\n            'Scan with your Keystone',\n            'After your Keystone has signed this data, click on \"Scan Keystone\" to receive the signature',\n        );\n        return '0x' + Buffer.concat([r, s, v]).toString('hex');\n    }\n\n    _addressFromIndex(pb: string, i: number): string {\n        this.checkKeyring();\n        if (!this.hdk) {\n            // @ts-ignore\n            this.hdk = HDKey.fromExtendedKey(this.xpub);\n        }\n        const dkey = this.hdk.derive(`${pb}/0/${i}`);\n        const address = '0x' + publicToAddress(dkey.publicKey, true).toString('hex');\n        return toChecksumAddress(address);\n    }\n\n    _pathFromAddress(address: string): string {\n        const checksummedAddress = toChecksumAddress(address);\n        let index = this.paths[checksummedAddress];\n        if (typeof index === 'undefined') {\n            for (let i = 0; i < MAX_INDEX; i++) {\n                if (checksummedAddress === this._addressFromIndex(pathBase, i)) {\n                    index = i;\n                    break;\n                }\n            }\n        }\n\n        if (typeof index === 'undefined') {\n            throw new Error('Unknown address');\n        }\n        return `${this.hdPath}/0/${index}`;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}